# Technical Task – Entravel: Order Processing Service

This repository contains a minimal Order Processing Service built with .NET 8.

Key endpoints:
- POST /orders — Accepts a new order and enqueues it for background processing.
- GET /metrics — Returns a snapshot of processed orders count.

In Development environment, Swagger UI is enabled at /swagger.


## How to run the service

### Run with Docker Compose
Prerequisites:
- Docker Desktop or Docker Engine + Docker Compose

Steps:
1) Open a terminal at the project root directory: TechnicalTaskEntravel
2) Start all services (app, Redis, MongoDB):
   docker compose up --build
3) Once started, open Swagger UI:
   http://localhost:5001/swagger/index.html

Notes:
- The API service is bound to http://localhost:5001 (container port 8080).
- Redis runs on localhost:6379, MongoDB runs on localhost:27017 (exposed by compose for convenience).


## Configuration
Configuration can be provided via appsettings.json.

Relevant settings:
- MongoDB
  - Mongo:ConnectionString (default for compose: mongodb://mongo:27017)
  - Mongo:Database (default: ordersdb)
  - Mongo:OrdersCollection (default: orders)
- Redis
  - Redis:Configuration (default for compose: redis:6379)
  - Redis:QueueKey (default: orders:queue)
- ASP.NET Core
  - ASPNETCORE_ENVIRONMENT (e.g., Development to enable Swagger UI)

When running via Docker Compose, these are pre-set in compose.yaml.


## API quickstart

- Submitting an order (http://localhost:5001/orders) it's not required to provide a customer id, it can be generated by the service for convenience.

Processing behavior: after you POST an order, the worker simulates ~10 seconds of processing time before marking the order as Processed in MongoDB. You can POST multiple orders; the worker processes them sequentially by default.


## Design decisions and trade-offs

- Simplicity-first, dev-focused setup
  - Reason: This is a technical task designed to be easy to run and reason about.
  - Trade-off: Minimal feature set; not production-hardened (no auth, no retries/backoff beyond basic loop, no DLQ).

- Asynchronous processing via Redis list
  - Reason: Redis is lightweight and ubiquitous; a List works as a simple queue.
  - Trade-offs:
    - At-least-once delivery: duplicates are possible; the worker and data model are not idempotent-aware.
    - No visibility timeout / reservation: if the worker crashes after dequeue, the job could be lost (no requeue semantics).
    - Polling with small delay is used instead of a blocking pop for simplicity; this is less efficient but easy to understand.

- MongoDB for persistence
  - Reason: Flexible schema and quick local setup.


## Assumptions

- Order model
  - Items is a list of string identifiers representing products.
  - TotalAmount is intentionally implemented as the count of items (i.e., number of items), not a monetary sum. This keeps the domain simple for the task.

- Identifiers
  - Order Ids and CustomerId are MongoDB ObjectIds. If CustomerId is not provided or invalid, the service generates a new ObjectId on submit for usability.

- Processing semantics
  - Processing is at-least-once, non-idempotent, and best-effort. Failures are logged and the worker continues; no retries / DLQ included.

- Environment & security
  - This is a local/dev-oriented setup; no authentication/authorization; suitable for demo/testing only.